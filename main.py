import os
import requests
from fastapi import FastAPI, Response
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import warnings
import pytz
import re

# ÂøΩÁï• InsecureRequestWarning Ë≠¶Âëä
from urllib3.exceptions import InsecureRequestWarning
warnings.simplefilter('ignore', InsecureRequestWarning)

# ÂàùÂßãÂåñ FastAPI ÊáâÁî®
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

CWA_API_KEY = os.environ.get('CWA_API_KEY', 'YOUR_API_KEY_IS_NOT_SET')
TAIPEI_TZ = pytz.timezone('Asia/Taipei')

# --- Helper Functions ---
def get_rain_level(value: float) -> tuple[str, str, str]:
    if value < 0: return "Ë≥áÊñôÁï∞Â∏∏", "rain-red", "Ë≥áÊñôÁï∞Â∏∏"
    if value > 200: return "üü• Ë±™Â§ßÈõ®", "rain-red", "Ë±™Â§ßÈõ®"
    if value > 130: return "üüß Ë±™Èõ®", "rain-orange", "Ë±™Èõ®"
    if value > 80: return "üü® Â§ßÈõ®", "rain-yellow", "Â§ßÈõ®"
    if value > 30: return "üü¶ ‰∏≠Èõ®", "rain-blue", "‰∏≠Èõ®"
    if value > 0: return "üü© Â∞èÈõ®", "rain-green", "Â∞èÈõ®"
    return "‚¨úÔ∏è ÁÑ°Èõ®", "rain-none", "ÁÑ°Èõ®"

# --- API Ë∑ØÁî±ÂÆöÁæ© ---
@app.get("/api/dashboard-data")
async def get_dashboard_data() -> Dict[str, Any]:
    current_time = datetime.now(TAIPEI_TZ).strftime("%Y-%m-%d %H:%M:%S")

    rain_info = await get_cwa_rain_data()
    earthquake_info = await get_cwa_earthquake_data()
    typhoon_info = await get_cwa_typhoon_data()
    road_info = await get_suhua_road_data()

    dashboard_data = {
        "lastUpdate": current_time,
        "rainInfo": rain_info,
        "earthquakeInfo": earthquake_info,
        "roadInfo": road_info,
        "typhoonInfo": typhoon_info
    }
    return dashboard_data

@app.get("/api/radar-image")
async def get_radar_image():
    image_url = "https://www.cwa.gov.tw/Data/radar/CV1_3600.png"
    try:
        response = requests.get(image_url, timeout=10, verify=False)
        response.raise_for_status()
        return Response(content=response.content, media_type="image/png")
    except requests.exceptions.RequestException as e:
        print(f"Error fetching radar image: {e}")
        return Response(status_code=404)

@app.get("/api/rainfall-map")
async def get_rainfall_map():
    image_url = "https://c1.1968services.tw/map-data/O-A0040-002.jpg"
    try:
        response = requests.get(image_url, timeout=10, verify=False)
        response.raise_for_status()
        return Response(content=response.content, media_type="image/jpeg")
    except requests.exceptions.RequestException as e:
        print(f"Error fetching rainfall map: {e}")
        return Response(status_code=404)

# --- Ë≥áÊñôÁç≤ÂèñÂáΩÂºè ---
async def get_cwa_rain_forecast() -> Dict[str, str]:
    location_names = "ËòáÊæ≥ÈéÆ,ÂçóÊæ≥ÈÑâ,ÁßÄÊûóÈÑâ,Êñ∞ÂüéÈÑâ"
    url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/F-D0047-091?Authorization={CWA_API_KEY}&locationName={location_names}&elementName=PoP6h"
    forecasts = {}
    try:
        response = requests.get(url, verify=False, timeout=15)
        response.raise_for_status()
        data = response.json()
        locations = data.get("records", {}).get("location", [])
        for loc in locations:
            loc_name = loc.get("locationName")
            weather_elements = loc.get("weatherElement", [])
            pop6h = next((el for el in weather_elements if el.get("elementName") == "PoP6h"), None)
            if pop6h and pop6h.get("time"):
                first_forecast_pop = int(pop6h["time"][0]["parameter"]["parameterValue"])
                if first_forecast_pop <= 10:
                    forecasts[loc_name] = "ÁÑ°ÊòéÈ°ØÈôçÈõ®"
                else:
                    forecasts[loc_name] = f"{first_forecast_pop}% Ê©üÁéáÈôçÈõ®"
            else:
                forecasts[loc_name] = "È†êÂ†±Ë≥áÊñôÁï∞Â∏∏"
    except requests.exceptions.RequestException as e:
        print(f"Error fetching rain forecast: {e}")
        for name in location_names.split(","):
            forecasts[name] = "È†êÂ†±ËÆÄÂèñÂ§±Êïó"
    return forecasts

async def get_cwa_rain_data() -> List[Dict[str, Any]]:
    station_ids = {"C0O920": "ËòáÊæ≥ÈéÆ", "C0U9N0": "ÂçóÊæ≥ÈÑâ", "C0Z030": "ÁßÄÊûóÈÑâ", "C0T8A0":"Êñ∞ÂüéÈÑâ"}
    forecast_data = await get_cwa_rain_forecast()
    url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/O-A0002-001?Authorization={CWA_API_KEY}&stationId={','.join(station_ids.keys())}"
    processed_data = []
    try:
        response = requests.get(url, verify=False, timeout=15)
        response.raise_for_status()
        data = response.json()
        stations_data = {station["stationId"]: station for station in data.get("records", {}).get("location", [])}
        for station_id, station_name in station_ids.items():
            station = stations_data.get(station_id)
            if station:
                rain_value_str = next((item["elementValue"] for item in station["weatherElement"] if item["elementName"] == "HOUR_24"), "0")
                rain_value = float(rain_value_str)
                obs_time = datetime.fromisoformat(station["time"]["obsTime"]).astimezone(TAIPEI_TZ).strftime("%H:%M")
                level_text, css_class, _ = get_rain_level(rain_value)
                processed_data.append({
                    "location": station_name, "mm": rain_value, "class": css_class,
                    "level": level_text, "time": obs_time,
                    "forecast": forecast_data.get(station_name, "È†êÂ†±ËÆÄÂèñÂ§±Êïó")
                })
            else:
                processed_data.append({ "location": station_name, "mm": "N/A", "class": "rain-nodata", "level": "Ê∏¨Á´ôÊö´ÁÑ°ÂõûÂ†±", "time": "", "forecast": forecast_data.get(station_name, "N/A") })
    except requests.exceptions.RequestException as e:
        print(f"Error fetching rain data: {e}")
        for station_name in station_ids.values():
            processed_data.append({"location": station_name, "mm": "N/A", "class": "rain-error", "level": "ËÆÄÂèñÂ§±Êïó", "time": "", "forecast": "N/A"})
    return processed_data

async def get_cwa_earthquake_data() -> List[Dict[str, Any]]:
    url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/E-A0015-001?Authorization={CWA_API_KEY}&limit=30"
    processed_data = []
    try:
        response = requests.get(url, verify=False, timeout=15)
        response.raise_for_status()
        data = response.json()
        if data.get("records") and data["records"].get("Earthquake"):
            three_days_ago = datetime.now(TAIPEI_TZ) - timedelta(days=3)
            for quake in data["records"]["Earthquake"]:
                earthquake_info = quake.get("EarthquakeInfo", {})
                quake_time_str = earthquake_info.get("OriginTime")
                if not quake_time_str: continue
                quake_time = datetime.fromisoformat(quake_time_str).astimezone(TAIPEI_TZ)
                if quake_time >= three_days_ago:
                    yilan_level_str = "0"; hualien_level_str = "0"
                    for area in quake.get("Intensity", {}).get("ShakingArea", []):
                        if area.get("AreaDesc") == "ÂÆúËò≠Á∏£": yilan_level_str = area.get("AreaIntensity", "0")
                        if area.get("AreaDesc") == "Ëä±ËìÆÁ∏£": hualien_level_str = area.get("AreaIntensity", "0")
                    try:
                        yilan_level_int = int(yilan_level_str.replace("Á¥ö", "")); hualien_level_int = int(hualien_level_str.replace("Á¥ö", ""))
                    except ValueError:
                        yilan_level_int = 0; hualien_level_int = 0
                    if yilan_level_int >= 2 or hualien_level_int >= 2:
                        epicenter = earthquake_info.get("Epicenter", {})
                        magnitude_info = earthquake_info.get("Magnitude", {})
                        magnitude_value = magnitude_info.get("MagnitudeValue", 0)
                        report_content = quake.get("ReportContent", "")
                        report_time_str = ""
                        if isinstance(report_content, dict): report_time_str = report_content.get("web", "")
                        report_time = datetime.fromisoformat(report_time_str).astimezone(TAIPEI_TZ).strftime("%H:%M") if report_time_str else ""
                        processed_data.append({
                            "time": quake_time.strftime("%Y-%m-%d %H:%M"), "location": epicenter.get("Location", "‰∏çÊòé"),
                            "magnitude": magnitude_value, "depth": earthquake_info.get("FocalDepth", 0),
                            "hualien_level": str(hualien_level_int), "yilan_level": str(yilan_level_int),
                            "data_time": report_time
                        })
    except requests.exceptions.RequestException as e:
        print(f"Error fetching earthquake data: {e}")
    return processed_data

async def get_cwa_typhoon_data() -> Optional[Dict[str, Any]]:
    url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/T-A0001-001?Authorization={CWA_API_KEY}"
    try:
        response = requests.get(url, verify=False, timeout=15)
        response.raise_for_status()
        data = response.json()
        if data.get("records") and data["records"].get("sea_typhoon_warning"):
            typhoon_warnings = data["records"]["sea_typhoon_warning"].get("typhoon_warning_summary",{}).get("SeaTyphoonWarning")
            if typhoon_warnings:
                typhoon = typhoon_warnings[0]
                update_time = datetime.fromisoformat(typhoon["issue_time"]).astimezone(TAIPEI_TZ).strftime("%H:%M")
                return {
                    "name": typhoon["typhoon_name"], "warning_type": typhoon["warning_type"],
                    "update_time": update_time, "location": typhoon["center_location"],
                    "wind_speed": typhoon["max_wind_speed"], "status": typhoon["warning_summary"]["content"],
                    "img_url": "https://www.cwa.gov.tw/Data/typhoon/TY_NEWS/TY_NEWS_0.jpg"
                }
    except requests.exceptions.RequestException as e:
        # Áï∂APIÂõûÂÇ≥404ÊôÇÔºå‰ª£Ë°®Ê≤íÊúâÈ¢±È¢®Ë≠¶Â†±ÔºåÈÄôÊòØÊ≠£Â∏∏ÊÉÖÊ≥ÅÔºåÊâÄ‰ª•Áõ¥Êé•passÂøΩÁï•ÈåØË™§
        if e.response and e.response.status_code == 404:
            pass
        else:
            # ÂÖ∂‰ªñÈåØË™§ÔºàÂ¶ÇÁ∂≤Ë∑ØÂïèÈ°åÔºâÂâáÂç∞Âá∫‰æÜ
            print(f"Error fetching typhoon data: {e}")
    return None

# ==============================================================================
# ===== ‚ú®Â∫ï‰∏ãÊòØ‰øÆÊîπÈÅéÂæåÁöÑË∑ØÊ≥ÅÂáΩÂºèÔºåÂ∑≤Âä†ÂÖ• User-Agent Ê®ôÈ†≠‰æÜÊ®°Êì¨ÁÄèË¶ΩÂô®‚ú® =====
# ==============================================================================
async def get_suhua_road_data() -> Dict[str, List[Dict[str, Any]]]:
    api_url = "https://www.1968services.tw/api/getIncidents"
    
    # „ÄêÊú¨Ê¨°‰øÆÊ≠£ÈáçÈªû„ÄëÂä†‰∏äheadersÔºåËÆìË´ãÊ±ÇÁúãËµ∑‰æÜÂÉè‰∏ÄÂÄãÊ≠£Â∏∏ÁöÑÁÄèË¶ΩÂô®
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
    }
    
    # ÂÆöÁæ©Ë∑ØÊÆµÂíåÈóúÈçµÂ≠ó (ËàáÊÇ®ÂéüÊú¨ÁöÑË®≠ÂÆöÁõ∏Âêå)
    sections = {
        "ËòáÊæ≥-ÂçóÊæ≥": ["ËòáÊæ≥", "Êù±Êæ≥", "ËòáÊæ≥ÈößÈÅì", "Êù±Êæ≥ÈößÈÅì", "Êù±Â≤≥ÈößÈÅì"],
        "ÂçóÊæ≥-ÂíåÂπ≥": ["ÂçóÊæ≥", "Ê≠¶Â°î", "Êº¢Êú¨", "ÂíåÂπ≥", "ËßÄÈü≥ÈößÈÅì", "Ë∞∑È¢®ÈößÈÅì"],
        "ÂíåÂπ≥-ÁßÄÊûó": ["ÂíåÂπ≥", "Âíå‰ªÅ", "Â¥áÂæ∑", "ÁßÄÊûó", "ÂíåÂπ≥ÈößÈÅì", "Âíå‰∏≠ÈößÈÅì", "Âíå‰ªÅÈößÈÅì", "‰∏≠‰ªÅÈößÈÅì", "‰ªÅÊ∞¥ÈößÈÅì", "Â§ßÊ∏ÖÊ∞¥ÈößÈÅì", "Èå¶ÊñáÈößÈÅì", "ÂåØÂæ∑ÈößÈÅì", "Â¥áÂæ∑ÈößÈÅì", "Ê∏ÖÊ∞¥Êñ∑Â¥ñ", "‰∏ãÊ∏ÖÊ∞¥Ê©ã", "Â§ßÊ∏ÖÊ∞¥"]
    }
    high_risk_keywords = ["Â∞ÅÈñâ", "‰∏≠Êñ∑", "ÂùçÊñπ"]
    downgrade_keywords = ["ÊîπÈÅì", "Êõø‰ª£ÈÅìË∑Ø", "Ë°åÈßõÂè∞9‰∏ÅÁ∑ö", "ÂñÆÁ∑öÈõôÂêë", "ÊàíË≠∑ÈÄöË°å", "ÊîæË°å"]
    mid_risk_keywords = ["ËêΩÁü≥", "ÊñΩÂ∑•", "ÁÆ°Âà∂", "‰∫ãÊïÖ", "Â£ÖÂ°û", "ËªäÂ§ö", "ÊøÉÈúß", "‰ΩúÊ•≠"]
    degree_keywords = ["ÂñÆÁ∑ö", "ÂñÆÂÅ¥", "ËªäÈÅì", "ÈùûÂÖ®Ë∑ØÂπÖ", "ÊÖ¢ËªäÈÅì", "Ê©üÂãï"]
    
    results = {name: [] for name in sections.keys()}
    
    try:
        # Â∞á headers Âä†ÂÖ•Âà∞ POST Ë´ãÊ±Ç‰∏≠
        response = requests.post(api_url, json={"region": "e"}, headers=headers, timeout=15)
        response.raise_for_status()
        
        # ÂòóË©¶Ëß£ÊûêJSONÔºåÂ¶ÇÊûúÈÄôÊ≠•Âá∫ÈåØÔºåÊúÉË¢´‰∏ãÈù¢ÁöÑ except ÊçïÊçâÂà∞
        incidents = response.json()
        
        print(f"ÈÄèÈÅé API Á∏ΩÂÖ±ÊâæÂà∞ {len(incidents)} ÂâáË∑ØÊ≥Å‰∫ã‰ª∂„ÄÇ")

        for incident in incidents:
            content = incident.get("dsc", "")
            report_time_str = incident.get("time", "")
            
            report_time = ""
            if report_time_str:
                try:
                    report_time = f"ÈÄöÂ†±ÊôÇÈñì: {datetime.strptime(report_time_str, '%Y-%m-%d %H:%M:%S').strftime('%Y-%m-%d %H:%M')}"
                except ValueError:
                    report_time = f"ÈÄöÂ†±ÊôÇÈñì: {datetime.now(TAIPEI_TZ).strftime('%Y-%m-%d %H:%M')}"
            
            detail_url = ""
            incident_id = incident.get("id")
            if incident_id:
                detail_url = f"https://www.1968services.tw/incident/{incident_id}"

            if any(keyword in content for keyword in ["Âè∞9Á∑ö", "ËòáËä±", "Âè∞9‰∏ÅÁ∑ö"]):
                status = "‰∫ã‰ª∂"; css_class = "road-yellow"; is_high_risk = False
                
                for keyword in high_risk_keywords:
                    if keyword in content:
                        status = keyword; css_class = "road-red"; is_high_risk = True; break
                if not is_high_risk:
                    for keyword in mid_risk_keywords:
                        if keyword in content:
                            status = keyword; css_class = "road-yellow"; break
                
                is_partial_closure = any(keyword in content for keyword in degree_keywords)
                has_downgrade_option = any(keyword in content for keyword in downgrade_keywords)
                if is_high_risk:
                    if is_partial_closure:
                        status = f"ÁÆ°Âà∂ ({status}ÂñÆÁ∑ö)"; css_class = "road-yellow"
                    elif has_downgrade_option:
                        status = f"ÁÆ°Âà∂ ({status}ÊîπÈÅì)"; css_class = "road-yellow"

                is_old_road_event = "Âè∞9‰∏ÅÁ∑ö" in content
                
                new_suhua_tunnels = ["ËòáÊæ≥ÈößÈÅì", "Êù±Êæ≥ÈößÈÅì", "ËßÄÈü≥ÈößÈÅì", "Ë∞∑È¢®ÈößÈÅì", "‰∏≠‰ªÅÈößÈÅì", "‰ªÅÊ∞¥ÈößÈÅì"]
                is_new_road_event = any(tunnel in content for tunnel in new_suhua_tunnels)
                
                if is_new_road_event:
                    is_old_road_event = False
                elif not is_old_road_event:
                    km_match = re.search(r'(\d+\.?\d*)[Kk]', content)
                    if km_match:
                        try:
                            km = float(km_match.group(1))
                            new_ranges = [(104, 113), (124, 145), (148, 160)]
                            if not any(start <= km <= end for start, end in new_ranges):
                                is_old_road_event = True
                        except ValueError:
                            pass
                
                for section_name, keywords in sections.items():
                    if any(keyword in content for keyword in keywords):
                        results[section_name].append({
                            "section": section_name, "status": status, "class": css_class,
                            "desc": f"Ôºà{content}Ôºâ", "time": report_time, "is_old_road": is_old_road_event,
                            "detail_url": detail_url
                        })
                        
    except Exception as e: # ÊîπÁÇ∫ÊçïÊçâÊõ¥Âª£Ê≥õÁöÑÈåØË™§ÔºåÂåÖÊã¨JSONËß£ÊûêÈåØË™§
        print(f"Error fetching road data from API: {e}")
        # Â¶ÇÊûúÈúÄË¶ÅÊõ¥Ë©≥Á¥∞ÁöÑÈô§ÈåØÔºåÂèØ‰ª•ÂèñÊ∂à‰∏ãÈù¢ÈÄôË°åÁöÑË®ªËß£ÔºåÁúãÁúã‰º∫ÊúçÂô®Âà∞Â∫ïÂõûÂÇ≥‰∫Ü‰ªÄÈ∫º
        # print(f"Response text from server: {response.text}")
        error_event = { "section": "ÂÖ®Á∑ö", "status": "ËÆÄÂèñÂ§±Êïó", "class": "road-red", "desc": "ÁÑ°Ê≥ïÈÄ£Êé•Ë∑ØÊ≥Å‰º∫ÊúçÂô®", "time": "", "is_old_road": False, "detail_url": "" }
        for section_name in sections.keys():
            results[section_name].append(error_event)
            
    return results

@app.get("/")
def read_root():
    return {"status": "Guardian Angel Dashboard FINAL VERSION is running."}

@app.head("/")
def read_root_head():
    return Response(status_code=200)
